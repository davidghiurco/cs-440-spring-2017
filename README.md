# cs-440-spring-2017
## CS 440 Pokefight Programming Language

### Poke-Fight
### A Pokemon Fighting Card Game Programming Language: Whitepaper
##### By: Alrick Sayasavanh, David Ghiurco, Szymon Krzeptowski-Mucha

#Introduction
The purpose of our language is to allow programmers to manipulate Pokemon types and power level. Programmers will be able to define their own Pokemon as well as they're power levels. The language will allow programmers to be able to test different relations with certain types and create their own rules for their own Pokemon world. Once the types and power levels have been established. The language creates a frame for programming a turn-based battle between two Pokemon to test which one wins.

## Language
Poke-Fight is a simple, portable language for 1-vs-1 simulations from each base type {Grass, Electric, Water, Fire}.

## Simple and Intuitive
The language abstracts the turn based mechanics and simplifies the programming of a fight between various Pokemon. The custom data type Pokemon has two attributes attached to it, which base type and its power. This allows the programmer to add new pokemon to the set easily.

## Portable
One of the primary goals of this programming languages is to be highly portable to allow cross-platform development of Pokemon fight games. As such, we will be using only core libraries beneath the scenes to allow for maximum portability.

## Language Features
### Custom Loops <br />
The game will be turn-based, making turns implemented by loops that continue until a Pokemon has defeated the other.

### Deterministic Battling <br />
The game will be deterministic, meaning the results are based off Pokemon types and power level. If a Pokemon is a type that is effective against another type, the stronger type's power level will enhance and the weaker type's power will be diminished.

### Custom Data Types <br />
There are several data types that are specialized for Pokemon. These values would be the following: Pokemon, Type, and Power. Pokemon provide the Type and Power. Type determines the attribute of the attacks provided by the Pokemon. Power determines how strong the attacks are provided by the Pokemon.

### The Runtime <br />
The core of Poke-Fight is a turn-based text interface that will allow a programmer to create a 1-vs-1 Pokemon tournament program. Once written, the program will declare the winner of the 2 players based on the type and power level of the used Pokemon.


# Grammar
The grammar will specify what inputs are valid in the language <br />
Note: <br />
Terminals are lowercase. Non-Terminals are uppercase. <br />

*Program => Pokefight main ( ) { Statements } <br />
Statements  => { Statement } <br />
Statement   => Assignment | Fight <br />
Assignment  => Declaration = Literal ; <br />
Declaration => Type identifier <br />
Literal     => int <br />
Type        => water | fire | grass | electric <br />
Pokemon     => Type Literal | identifier
Fight       => Fight FIGHT Pokemon | Pokemon; <br />*

This grammar is _unambiguous_ because it contains no operators of different precedence and recursion is kept to a minimum. For any input, there will be only one left-most derivation. <br />

We chose to keep the grammar unambiguous for now to only support 1v1 fights. It may become more complicated in the future if we decide to add many-vs-many pokemon fight functionality.

# How the parser works

```
The ocamllex command produces a lexical analyzer from a set of regular expressions with attached semantic actions, in the style of lex. Assuming the input file is lexer.mll, executing

        ocamllex lexer.mll

produces OCaml code for a lexical analyzer in file lexer.ml. This file defines one lexing function per entry point in the lexer definition. These functions have the same names as the entry points. Lexing functions take as argument a lexer buffer, and return the semantic attribute of the corresponding entry point.

Lexer buffers are an abstract data type implemented in the standard library module Lexing. The functions Lexing.from_channel, Lexing.from_string and Lexing.from_function create lexer buffers that read from an input channel, a character string, or any reading function, respectively. (See the description of module Lexing in chapter 23.)

When used in conjunction with a parser generated by ocamlyacc, the semantic actions compute a value belonging to the type token defined by the generated parsing module. (See the description of ocamlyacc below.)

```
src: https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html#sec296

The language uses a global symbols table is implemented with a hash table.

```
The ocamlyacc command produces a parser from a context-free grammar specification with attached semantic actions, in the style of yacc. Assuming the input file is grammar.mly, executing

        ocamlyacc options grammar.mly

produces OCaml code for a parser in the file grammar.ml, and its interface in file grammar.mli.

The generated module defines one parsing function per entry point in the grammar. These functions have the same names as the entry points. Parsing functions take as arguments a lexical analyzer (a function from lexer buffers to tokens) and a lexer buffer, and return the semantic attribute of the corresponding entry point. Lexical analyzer functions are usually generated from a lexer specification by the ocamllex program. Lexer buffers are an abstract data type implemented in the standard library module Lexing. Tokens are values from the concrete type token, defined in the interface file grammar.mli produced by ocamlyacc.
```
src: https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html#sec307

# How to Run (Command-line Interpreter)

```
$ make clean && make
$ ./pokemon
```

# Commands able to run
----

To run a pokemon battle without instantiation

Input:
```
fire 3 fight water 2;
```

Output:
```
>> WATER beats FIRE by 1 damage
1
```
---

To store a pokemon into the symbols table

Input:
```
fire charmander = 10;
```

Output:
```
10
```

---

To call a variable from the symbols table. It will return the value

Input:
```
charmander;
```

Output:
```
10
```

---

Have two identifiers fight each other

Input:
```
water squirtle = 8;
charmander fight squirtle;
```

Output:
```
WATER beats FIRE by 6 damage
6
```
---

Syntax Error

Input:
```
```

Output:
```
```
---

Name Error

Input:
```
FRE 2 FIGHT WATER 3;
```

Output:
```
Fatal error: exception Parser.Name_error("FRE is not defined")
```
---

Type Check Error

Input:
```
FIRE FOUR FIGHT WATER 3;
```

Output:
```
Fatal error: exception Parser.Typecheck_error("Invalid Type")
```
---
